# -*- coding: utf-8 -*-
"""Ogmen-Task(Q2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HT4CireKP9GKXNI4Zb1euc0cDIsCfftr

Tanuj Ohri

21070127052
"""

from google.colab import drive
import os


drive.mount('/content/drive', force_remount=True)


images_path = '/content/drive/MyDrive/images2'
print("Files in the directory:")
print(os.listdir(images_path))

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import glob

def load_images_from_folder(folder):
    images = []
    for filename in glob.glob(folder + '/*.jpg'):
        img = cv2.imread(filename)
        if img is not None:
            images.append(img)
    print(f"Loaded {len(images)} images from folder {folder}")
    return images

def preprocess_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    plt.figure(figsize=(10, 10))
    plt.imshow(edges, cmap='gray')
    plt.title('Edge Detection')
    plt.axis('off')
    plt.show()
    return edges

def line_segment_detection(image):
    lsd = cv2.createLineSegmentDetector(0)
    lines = lsd.detect(image)[0]  # Only unpack the first element
    if lines is not None:
        lines = lines.reshape(-1, 4)
        print(f"Detected {len(lines)} line segments")
    else:
        print("No line segments detected")
        lines = []
    return lines

def find_intersections(lines, img_shape):
    intersections = []
    for i, line1 in enumerate(lines):
        for line2 in lines[i+1:]:
            x1, y1, x2, y2 = line1
            x3, y3, x4, y4 = line2
            a1 = y2 - y1
            b1 = x1 - x2
            c1 = a1 * x1 + b1 * y1
            a2 = y4 - y3
            b2 = x3 - x4
            c2 = a2 * x3 + b2 * y3
            determinant = a1 * b2 - a2 * b1
            if determinant != 0:
                x = (b2 * c1 - b1 * c2) / determinant
                y = (a1 * c2 - a2 * c1) / determinant
                if 0 <= x <= img_shape[1] and 0 <= y <= img_shape[0]:
                    intersections.append([x, y])
    print(f"Found {len(intersections)} intersections")
    return intersections

def cluster_intersections(intersections):
    if len(intersections) == 0:
        return []
    db = DBSCAN(eps=10, min_samples=1).fit(intersections)
    labels = db.labels_
    unique_labels = set(labels)
    clustered_points = []
    for k in unique_labels:
        class_member_mask = (labels == k)
        xy = np.array(intersections)[class_member_mask]
        centroid = np.mean(xy, axis=0)
        clustered_points.append(centroid)
    print(f"Clustered into {len(clustered_points)} points")
    return clustered_points

def visualize_vanishing_points(image, points):
    for point in points:
        x, y = point
        cv2.circle(image, (int(x), int(y)), 5, (0, 0, 255), -1)

    # Converting image from BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    plt.figure(figsize=(10, 10))
    plt.imshow(image_rgb)
    plt.title('Vanishing Points')
    plt.axis('off')
    plt.show()

# Loading images from the folder
images = load_images_from_folder(images_path)
if not images:
    print("No images found. Please check the path and upload images to the folder.")

# Processing each image
for idx, image in enumerate(images):
    print(f"Processing image {idx+1}/{len(images)}")
    edges = preprocess_image(image)
    lines = line_segment_detection(edges)

    if lines.any():
        intersections = find_intersections(lines, image.shape)
        if intersections:
            clustered_points = cluster_intersections(intersections)
            if clustered_points:
                visualize_vanishing_points(image, clustered_points)
            else:
                print("No clustered points found.")
        else:
            print("No intersections found in the image.")
    else:
        print("No lines detected in the image.")

"""ANOTHER EXPERIMENT"""

from google.colab import drive
import os


drive.mount('/content/drive', force_remount=True)


images_path = '/content/drive/MyDrive/images2'
print("Files in the directory:")
print(os.listdir(images_path))

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import glob

def load_images_from_folder(folder):
    images = []
    for filename in glob.glob(folder + '/*.jpg'):
        img = cv2.imread(filename)
        if img is not None:
            images.append(img)
    print(f"Loaded {len(images)} images from folder {folder}")
    return images

def preprocess_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    plt.figure(figsize=(10, 10))
    plt.imshow(edges, cmap='gray')
    plt.title('Edge Detection')
    plt.axis('off')
    plt.show()
    return edges

def line_segment_detection(image):
    lsd = cv2.createLineSegmentDetector(0)
    lines = lsd.detect(image)[0]  # Only unpack the first element
    if lines is not None:
        lines = lines.reshape(-1, 4)
        print(f"Detected {len(lines)} line segments")
    else:
        print("No line segments detected")
        lines = []
    return lines

def find_intersections(lines, img_shape):
    intersections = []
    for i, line1 in enumerate(lines):
        for line2 in lines[i+1:]:
            x1, y1, x2, y2 = line1
            x3, y3, x4, y4 = line2
            a1 = y2 - y1
            b1 = x1 - x2
            c1 = a1 * x1 + b1 * y1
            a2 = y4 - y3
            b2 = x3 - x4
            c2 = a2 * x3 + b2 * y3
            determinant = a1 * b2 - a2 * b1
            if determinant != 0:
                x = (b2 * c1 - b1 * c2) / determinant
                y = (a1 * c2 - a2 * c1) / determinant
                if 0 <= x <= img_shape[1] and 0 <= y <= img_shape[0]:
                    intersections.append([x, y])
    print(f"Found {len(intersections)} intersections")
    return intersections

def cluster_intersections(intersections):
    if len(intersections) == 0:
        return []
    db = DBSCAN(eps=10, min_samples=1).fit(intersections)
    labels = db.labels_
    unique_labels = set(labels)
    clustered_points = []
    for k in unique_labels:
        class_member_mask = (labels == k)
        xy = np.array(intersections)[class_member_mask]
        centroid = np.mean(xy, axis=0)
        clustered_points.append(centroid)
    print(f"Clustered into {len(clustered_points)} points")
    return clustered_points

def visualize_vanishing_points(image, lines, points):
    # Drawing lines
    for line in lines:
        x1, y1, x2, y2 = map(int, line)
        cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

    # Drawing vanishing points
    for point in points:
        x, y = map(int, point)
        cv2.circle(image, (x, y), 10, (0, 0, 255), -1)

    # Converting image from BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    plt.figure(figsize=(10, 10))
    plt.imshow(image_rgb)
    plt.title('Vanishing Points and Line Segments')
    plt.axis('off')
    plt.show()

# Loading images from the folder
images = load_images_from_folder(images_path)
if not images:
    print("No images found. Please check the path and upload images to the folder.")

# Processing each image
for idx, image in enumerate(images):
    print(f"Processing image {idx+1}/{len(images)}")
    edges = preprocess_image(image)
    lines = line_segment_detection(edges)

    if lines.any():
        intersections = find_intersections(lines, image.shape)
        if intersections:
            clustered_points = cluster_intersections(intersections)
            if clustered_points:
                visualize_vanishing_points(image, lines, clustered_points)
            else:
                print("No clustered points found.")
        else:
            print("No intersections found in the image.")
    else:
        print("No lines detected in the image.")

"""ANOTHER ATTEMPT"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import glob
import os

from google.colab import drive


drive.mount('/content/drive', force_remount=True)


images_path = '/content/drive/MyDrive/images2'
print("Files in the directory:")
print(os.listdir(images_path))

def load_images_from_folder(folder):
    images = []
    for filename in glob.glob(folder + '/*.jpg'):
        img = cv2.imread(filename)
        if img is not None:
            print(f"Loaded image {filename} with shape {img.shape}")
            images.append(img)
    print(f"Loaded {len(images)} images from folder {folder}")
    return images


images = load_images_from_folder(images_path)
if not images:
    print("No images found. Please check the path and upload images to the folder.")

def preprocess_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Adjusting the Canny thresholds
    edges = cv2.Canny(gray, 30, 100, apertureSize=3)

    plt.figure(figsize=(10, 10))
    plt.imshow(edges, cmap='gray')
    plt.title('Edge Detection')
    plt.axis('off')
    plt.show()

    return edges

def line_segment_detection(image):
    lsd = cv2.createLineSegmentDetector(0)
    lines = lsd.detect(image)[0]  # Only unpack the first element

    print(f"Detected lines before filtering: {lines}")

    if lines is not None:
        lines = lines.reshape(-1, 4)
        lines = filter_lines(lines)  # Filtering lines based on length
        print(f"Detected {len(lines)} line segments after filtering")
    else:
        print("No line segments detected")
        lines = []
    return lines

def filter_lines(lines, min_length=10):  # Reducing minimum length
    filtered_lines = []
    for line in lines:
        x1, y1, x2, y2 = line
        length = np.sqrt((x2 - x1)*2 + (y2 - y1)*2)
        if length > min_length:
            filtered_lines.append(line)
    return np.array(filtered_lines)

def find_intersections(lines, img_shape):
    intersections = []
    for i, line1 in enumerate(lines):
        for line2 in lines[i+1:]:
            x1, y1, x2, y2 = line1
            x3, y3, x4, y4 = line2
            a1 = y2 - y1
            b1 = x1 - x2
            c1 = a1 * x1 + b1 * y1
            a2 = y4 - y3
            b2 = x3 - x4
            c2 = a2 * x3 + b2 * y3
            determinant = a1 * b2 - a2 * b1
            if determinant != 0:
                x = (b2 * c1 - b1 * c2) / determinant
                y = (a1 * c2 - a2 * c1) / determinant
                if 0 <= x <= img_shape[1] and 0 <= y <= img_shape[0]:
                    intersections.append([x, y])
    print(f"Found {len(intersections)} intersections")
    return intersections

def cluster_intersections(intersections):
    if len(intersections) == 0:
        return []
    db = DBSCAN(eps=20, min_samples=1).fit(intersections)
    labels = db.labels_
    unique_labels = set(labels)
    clustered_points = []
    for k in unique_labels:
        class_member_mask = (labels == k)
        xy = np.array(intersections)[class_member_mask]
        centroid = np.mean(xy, axis=0)
        clustered_points.append(centroid)
    print(f"Clustered into {len(clustered_points)} points")
    return clustered_points

def visualize_vanishing_points(image, lines, points):
    image = image.copy()

    # Drawing lines
    for line in lines:
        x1, y1, x2, y2 = map(int, line)
        cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

    # Drawing vanishing points
    for point in points:
        x, y = point
        cv2.circle(image, (int(x), int(y)), 10, (0, 0, 255), -1)

    # Converting image from BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    plt.figure(figsize=(10, 10))
    plt.imshow(image_rgb)
    plt.title('Vanishing Points and Line Segments')
    plt.axis('off')
    plt.show()

# Processing each image
for idx, image in enumerate(images):
    print(f"Processing image {idx+1}/{len(images)}")
    edges = preprocess_image(image)
    lines = line_segment_detection(edges)
    if len(lines) > 0:
        intersections = find_intersections(lines, image.shape)
        if intersections:
            clustered_points = cluster_intersections(intersections)
            if clustered_points:
                visualize_vanishing_points(image, lines, clustered_points)
            else:
                print("No clustered points found.")
        else:
            print("No intersections found in the image.")
    else:
        print("No lines detected in the image.")

"""ANOTHER ATTEMPT"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import glob
import os

from google.colab import drive


drive.mount('/content/drive', force_remount=True)


images_path = '/content/drive/MyDrive/images2'
print("Files in the directory:")
print(os.listdir(images_path))

def load_images_from_folder(folder):
    images = []
    for filename in glob.glob(folder + '/*.jpg'):
        img = cv2.imread(filename)
        if img is not None:
            print(f"Loaded image {filename} with shape {img.shape}")
            images.append(img)
    print(f"Loaded {len(images)} images from folder {folder}")
    return images

# Load images from the folder
images = load_images_from_folder(images_path)
if not images:
    print("No images found. Please check the path and upload images to the folder.")

def preprocess_image(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Adjusting the Canny thresholds
    edges = cv2.Canny(gray, 30, 100, apertureSize=3)

    plt.figure(figsize=(10, 10))
    plt.imshow(edges, cmap='gray')
    plt.title('Edge Detection')
    plt.axis('off')
    plt.show()

    return edges

def line_segment_detection(image):
    lsd = cv2.createLineSegmentDetector(0)
    lines = lsd.detect(image)[0]  # Only unpacking the first element

    print(f"Detected lines before filtering: {lines}")

    if lines is not None:
        lines = lines.reshape(-1, 4)
        lines = filter_lines(lines)  # Filtering lines based on length
        print(f"Detected {len(lines)} line segments after filtering")
    else:
        print("No line segments detected")
        lines = []
    return lines

def filter_lines(lines, min_length=10):  # Reducing minimum length
    filtered_lines = []
    for line in lines:
        x1, y1, x2, y2 = line
        length = np.sqrt((x2 - x1)*2 + (y2 - y1)*2)
        if length > min_length:
            filtered_lines.append(line)
    return np.array(filtered_lines)

def find_intersections(lines, img_shape):
    intersections = []
    for i, line1 in enumerate(lines):
        for line2 in lines[i+1:]:
            x1, y1, x2, y2 = line1
            x3, y3, x4, y4 = line2
            a1 = y2 - y1
            b1 = x1 - x2
            c1 = a1 * x1 + b1 * y1
            a2 = y4 - y3
            b2 = x3 - x4
            c2 = a2 * x3 + b2 * y3
            determinant = a1 * b2 - a2 * b1
            if determinant != 0:
                x = (b2 * c1 - b1 * c2) / determinant
                y = (a1 * c2 - a2 * c1) / determinant
                if 0 <= x <= img_shape[1] and 0 <= y <= img_shape[0]:
                    intersections.append([x, y])
    print(f"Found {len(intersections)} intersections")
    return intersections

def cluster_intersections(intersections):
    if len(intersections) == 0:
        return []
    db = DBSCAN(eps=20, min_samples=1).fit(intersections)
    labels = db.labels_
    unique_labels = set(labels)
    clustered_points = []
    for k in unique_labels:
        class_member_mask = (labels == k)
        xy = np.array(intersections)[class_member_mask]
        centroid = np.mean(xy, axis=0)
        clustered_points.append(centroid)
    print(f"Clustered into {len(clustered_points)} points")

    # Selecting the most prominent cluster
    if len(clustered_points) > 0:
        cluster_sizes = [np.sum(labels == k) for k in unique_labels]
        main_cluster_index = np.argmax(cluster_sizes)
        return [clustered_points[main_cluster_index]]

    return clustered_points

def filter_lines_towards_vp(lines, vp, threshold=0.1):
    filtered_lines = []
    for line in lines:
        x1, y1, x2, y2 = line
        dx1, dy1 = x1 - vp[0], y1 - vp[1]
        dx2, dy2 = x2 - vp[0], y2 - vp[1]
        direction1 = np.arctan2(dy1, dx1)
        direction2 = np.arctan2(dy2, dx2)
        if abs(direction1 - direction2) < threshold:
            filtered_lines.append(line)
    return filtered_lines

def visualize_vanishing_points(image, lines, point):
    image = image.copy()

    # Drawing lines
    for line in lines:
        x1, y1, x2, y2 = map(int, line)
        cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

    #  vanishing point
    if point:
        x, y = point[0]
        cv2.circle(image, (int(x), int(y)), 10, (0, 0, 255), -1)

    # Converting image from BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    plt.figure(figsize=(10, 10))
    plt.imshow(image_rgb)
    plt.title('Vanishing Point and Line Segments')
    plt.axis('off')
    plt.show()

# Process each image
for idx, image in enumerate(images):
    print(f"Processing image {idx+1}/{len(images)}")
    edges = preprocess_image(image)
    lines = line_segment_detection(edges)
    if len(lines) > 0:
        intersections = find_intersections(lines, image.shape)
        if intersections:
            clustered_points = cluster_intersections(intersections)
            if clustered_points:
                vanishing_point = clustered_points[0]
                filtered_lines = filter_lines_towards_vp(lines, vanishing_point)
                visualize_vanishing_points(image, filtered_lines, [vanishing_point])
            else:
                print("No clustered points found.")
        else:
            print("No intersections found in the image.")
    else:
        print("No lines detected in the image.")